[TOC](/docs/TOC.md)

## アーキテクチャ決定記録 (ADR) ガイド

このドキュメントは、私たちのチームがアーキテクチャに関する重要な決定を記録するために採用する\*\*ADR（Architecture Decision Record）\*\*について、その目的、フォーマット、そして具体的な実践例をまとめたものです。

### 1\. ADRとは何か？

**ADR**は、アーキテクチャに関する\*\*重要な決定（と、その理由）\*\*を記録するための、軽量なテキストドキュメントです。なぜその技術を選んだのか、なぜその設計パターンを採用したのか、といった背景や経緯を未来のチームメンバーに伝えるための「航海日誌」や「議事録」のようなものです。

ADRは、コードそのものではなく、\*\*「なぜ、そのコードがそうなっているのか」\*\*を説明します。

#### 🎯 目的とメリット

  * **知識の継承**: プロジェクトの歴史的経緯や技術選定の理由が明確になり、新しいメンバーのキャッチアップを助けます。
  * **将来の意思決定の補助**: 過去の決定を振り返ることで、「なぜ以前はそうしなかったのか」という議論を避け、より良い意思決定ができます。
  * **明確化と合意形成**: 決定の背景やトレードオフを書き出すことで、思考が整理され、チーム内での合意形成がスムーズになります。
  * **手戻りの防止**: 一度議論して決定した内容を記録することで、同じ議論の蒸し返しを防ぎます。

-----

### 2\. ADRの基本フォーマット

ADRはシンプルなMarkdownファイルで記述します。決まった形式はありませんが、以下のフォーマットを基本とします。

> ```markdown
> # [連番]-[決定タイトル]
>
> * **ステータス**: 提案中 / 承認済み / 却下 / 廃止
> * **日付**: YYYY-MM-DD
>
> ## コンテキスト (Context)
> この決定が必要になった背景、問題、制約条件などを記述します。
> 「どのような課題を解決しようとしているのか？」
>
> ## 決定 (Decision)
> 最終的に下した決定を明確かつ簡潔に記述します。
> 「私たちは、〜することに決定した。」
>
> ## 結果 (Consequences)
> この決定によってもたらされるプラスとマイナスの影響（トレードオフ）を記述します。
> * **メリット**: 〜ができるようになる、〜が改善される
> * **デメリット**: 〜という新たな制約が生まれる、〜の学習コストがかかる
> * **その他**: 中立的な影響
> ```

-----

### 3\. 具体例：ADRとそれに対応するPython実装

ここでは、「HTTPリクエストを行うためのライブラリ選定」というシナリオでADRを作成し、その決定がどのようにPythonコードに反映されるかを示します。

#### ADRの例

> [!path] `docs/architecture/decisions/001-use-httpx-for-http-client.md`
>
> ```markdown
> # 001: HTTPクライアントとしてhttpxを採用する
>
> * **ステータス**: 承認済み
> * **日付**: 2025-07-06
>
> ## コンテキスト
> 外部APIとの通信のために、HTTPクライアントライブラリが必要である。
> 将来的には非同期処理(async/await)によるパフォーマンス向上が見込まれるため、同期・非同期の両方に対応できるライブラリが望ましい。標準的な`requests`ライブラリは同期的処理にしか対応していない。
>
> ## 決定
> 標準のHTTPクライアントライブラリとして **`httpx`** を採用する。
> 同期・非同期の両方のユースケースに対応するため、このライブラリをラップした社内モジュールを作成する。
>
> ## 結果
> * **メリット**:
>     * 一つのライブラリで、同期・非同期両方のAPI呼び出しに対応できる。
>     * `requests`と似たAPIを持っており、学習コストが低い。
>     * パフォーマンスが良い。
> * **デメリット**:
>     * チーム内での知名度が`requests`に比べてやや低く、新しいメンバーへの周知が必要。
>     * プロジェクトの依存関係が一つ増える。
> ```

#### ADRを反映したPython実装例

上記のADRの決定に基づき、`httpx`を使った共通モジュールを作成します。

`app/utils/http_client.py`

```python
import httpx
from typing import Dict, Any

# ===================================================================
# このモジュールはADR-001の決定に基づき、httpxを標準クライアントとして使用します。
# 理由: 同期・非同期の両方に対応するため。
# ===================================================================

# --- 同期クライアント ---
def fetch_sync(url: str) -> Dict[str, Any]:
    """
    同期的にAPIからデータを取得する
    """
    try:
        with httpx.Client() as client:
            response = client.get(url)
            response.raise_for_status()  # 2xx以外のステータスコードで例外を発生
            return response.json()
    except httpx.HTTPStatusError as e:
        print(f"HTTPエラー: {e.response.status_code}")
        raise
    except httpx.RequestError as e:
        print(f"リクエストエラー: {e}")
        raise

# --- 非同期クライアント ---
async def fetch_async(url: str) -> Dict[str, Any]:
    """
    非同期的にAPIからデータを取得する
    """
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url)
            response.raise_for_status()
            return response.json()
    except httpx.HTTPStatusError as e:
        print(f"HTTPエラー: {e.response.status_code}")
        raise
    except httpx.RequestError as e:
        print(f"リクエストエラー: {e}")
        raise

```

この実装例では、ADRで決定した`httpx`を使い、さらに決定理由であった「同期・非同期の両対応」を具体的な関数として実現しています。コード内のコメントでADR番号に言及することで、コードと決定のトレーサビリティを確保しています。

### まとめ

ADRは、私たちの技術的な意思決定の「なぜ」を記録するためのシンプルで強力なツールです。全ての決定を記録する必要はありませんが、後から「なぜこうなっているんだっけ？」と疑問に思いそうな重要な決定については、ADRを残すことを習慣づけましょう。これにより、プロジェクトの保守性、透明性、そしてチームの知識共有が大きく促進されます。

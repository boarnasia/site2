"""
パイプライン統合テスト

Fetch → Detect → Build の全体フローをテストする
"""

import pytest
from pathlib import Path
from dependency_injector import providers

from site2.core.containers import TestContainer
from tests.mocks.services import (
    MockFetchService,
    MockDetectService,
    MockBuildService,
    MockRepository,
)


class TestPipelineIntegration:
    """パイプライン統合テストクラス"""

    def setup_method(self):
        """各テストメソッドの前に実行される"""
        self.container = TestContainer()

        # モックサービスで上書き
        self.container.website_cache_repository.override(
            providers.Singleton(MockRepository)
        )
        self.container.fetch_service.override(
            providers.Factory(
                MockFetchService,
                repository=self.container.website_cache_repository,
            )
        )
        self.container.detect_service.override(providers.Factory(MockDetectService))
        self.container.build_service.override(providers.Factory(MockBuildService))

    @pytest.mark.asyncio
    async def test_individual_services(self):
        """個別サービスが正常に動作することを確認"""

        # Fetch Service のテスト
        fetch_service = self.container.fetch_service()
        fetch_result = await fetch_service.execute("http://test-site")

        assert str(fetch_result.root_url) == "http://test-site/"
        assert fetch_result.pages_fetched == 1
        assert fetch_result.total_size > 0

        # Detect Service のテスト
        detect_service = self.container.detect_service()
        html_content = fetch_result._html_content

        main_content = await detect_service.detect_main_content(html_content)
        assert main_content.selector == "main.content"
        assert "Welcome to Test Site" in main_content.text_content

        navigation = await detect_service.detect_navigation(html_content)
        assert navigation.selector == "nav.navigation"
        assert len(navigation.structure.links) == 3

        doc_order = await detect_service.detect_order(
            Path(fetch_result.cache_directory),
            navigation,  # ナビゲーションデータを渡す
        )
        assert len(doc_order.files) == 3
        assert doc_order.method == "navigation"

        # Build Service のテスト
        build_service = self.container.build_service()
        markdown_doc = await build_service.build_markdown([main_content], doc_order)

        assert "Welcome to Test Site" in markdown_doc.title
        assert "Welcome to Test Site" in markdown_doc.content
        assert "Generated by MockBuildService" in markdown_doc.content

    @pytest.mark.asyncio
    async def test_full_pipeline(self):
        """パイプライン全体の動作確認"""

        # Step 1: Fetch
        fetch_service = self.container.fetch_service()
        fetch_result = await fetch_service.execute("http://test-site")

        # Step 2: Detect
        detect_service = self.container.detect_service()
        html_content = fetch_result._html_content

        # 2.1: メインコンテンツの検出
        main_content = await detect_service.detect_main_content(html_content)

        # 2.2: ナビゲーションの検出
        navigation = await detect_service.detect_navigation(html_content)

        # 2.3: ナビゲーションを使って順序を決定
        doc_order = await detect_service.detect_order(
            Path(fetch_result.cache_directory),
            navigation,  # 重要：ナビゲーションデータを渡す
        )

        # Step 3: Build
        build_service = self.container.build_service()
        markdown = await build_service.build_markdown(
            [main_content],
            doc_order,  # 重要：順序データを渡す
        )

        # 検証
        assert "Welcome to Test Site" in markdown.content
        assert "Document Order: 3 files" in markdown.content  # 順序情報の確認
        assert markdown.metadata is not None
        assert markdown.metadata.source_url == "http://test-site"

    @pytest.mark.asyncio
    async def test_pipeline_with_multiple_contents(self):
        """複数コンテンツでのパイプラインテスト"""

        # Fetch と Detect
        fetch_service = self.container.fetch_service()
        detect_service = self.container.detect_service()
        build_service = self.container.build_service()

        fetch_result = await fetch_service.execute("http://test-site")
        html_content = fetch_result._html_content

        # 複数のMainContentを作成（実際のシナリオを模擬）
        main_content1 = await detect_service.detect_main_content(html_content)
        main_content2 = await detect_service.detect_main_content(html_content)
        main_content2.title = "Second Content"
        main_content2.text_content = "This is the second content section."

        # ナビゲーションと順序を取得
        navigation = await detect_service.detect_navigation(html_content)
        doc_order = await detect_service.detect_order(
            Path(fetch_result.cache_directory), navigation
        )

        # Build
        markdown = await build_service.build_markdown(
            [main_content1, main_content2], doc_order
        )

        # 最初のコンテンツのみが処理されることを確認（MockBuildServiceの仕様）
        assert "Welcome to Test Site" in markdown.content
        assert markdown.title == "Welcome to Test Site"

    @pytest.mark.asyncio
    async def test_pipeline_error_handling(self):
        """パイプラインのエラーハンドリング"""

        # Build Service に空のコンテンツリストを渡す
        build_service = self.container.build_service()
        detect_service = self.container.detect_service()  # noqa: F841

        # ダミーのDocumentOrderを作成
        from site2.core.domain.detect_domain import DocumentOrder, DetectionScore

        dummy_order = DocumentOrder(
            files=[], method="unknown", confidence=DetectionScore.none()
        )

        with pytest.raises(ValueError, match="No content provided"):
            await build_service.build_markdown([], dummy_order)

    @pytest.mark.asyncio
    async def test_service_data_flow(self):
        """サービス間のデータフローを詳細に検証"""

        fetch_service = self.container.fetch_service()
        detect_service = self.container.detect_service()
        build_service = self.container.build_service()

        # Fetch の結果を詳細に確認
        fetch_result = await fetch_service.execute("http://test-site")

        assert hasattr(fetch_result, "cache_id")
        assert hasattr(fetch_result, "root_url")
        assert hasattr(fetch_result, "cache_directory")
        assert hasattr(fetch_result, "pages_fetched")

        # HTMLコンテンツが取得できることを確認
        html_content = fetch_result._html_content
        assert isinstance(html_content, str)
        assert len(html_content) > 0

        # Detect の結果を詳細に確認
        main_content = await detect_service.detect_main_content(html_content)

        assert hasattr(main_content, "selector")
        assert hasattr(main_content, "html_content")
        assert hasattr(main_content, "text_content")
        assert hasattr(main_content, "title")
        assert hasattr(main_content, "confidence")

        # ナビゲーションと順序を取得
        navigation = await detect_service.detect_navigation(html_content)
        doc_order = await detect_service.detect_order(
            Path(fetch_result.cache_directory), navigation
        )

        # Build の結果を詳細に確認
        markdown = await build_service.build_markdown([main_content], doc_order)

        assert hasattr(markdown, "title")
        assert hasattr(markdown, "content")
        assert hasattr(markdown, "metadata")
        assert hasattr(markdown, "source_files")

        # メソッドが正常に動作することを確認
        assert isinstance(markdown.get_word_count(), int)
        assert isinstance(markdown.get_line_count(), int)
        assert isinstance(markdown.get_toc_markdown(), str)

    def test_sync_compatibility(self):
        """同期的なコンテナ操作の互換性確認"""

        # サービスインスタンスの取得は同期的に行える
        fetch_service = self.container.fetch_service()
        detect_service = self.container.detect_service()
        build_service = self.container.build_service()
        repository = self.container.website_cache_repository()

        # インスタンスの型を確認
        assert isinstance(fetch_service, MockFetchService)
        assert isinstance(detect_service, MockDetectService)
        assert isinstance(build_service, MockBuildService)
        assert isinstance(repository, MockRepository)
